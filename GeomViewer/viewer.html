
<html>

<head>
	<title>My first three.js app</title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			width: 100%;
			height: 100%
		}
	</style>
</head>

<body>
	<div id="generation" style="width:50%">

	</div>
	<button type="button" style="right:0" onclick="next()">Next </button>
	<button type="button" style = "right : 10%" onclick="pre()">Previous </button>
	<button type="button" id="raw" style = "left : 10%" onclick="showRaw()">RAW</button>
    <button type="button" onclick="toggleData()"> TOGGLE </button>
	<button type= "button" onclick="showDoubleSide()"> DoubleSide </button>
	<div id="container"></div>
	<script src="js/lib/three.js"></script>
	<script src="js/lib/earcut.js"></script>
	<script src="js/lib/jquery.js"></script>
	<script src="js/threejs/renderers/Projector.js"></script>
	<script src="js/threejs/renderers/CanvasRenderer.js"></script>
	<script src="js/lib/jquery.mousewheel.js"></script>
	<script src="js/threejs/controls/TrackballControls.js"></script>
	<script>
		var version = "v1.0.0.1";
        var data_index = 0;
        var data_array = ["office","171103_APT", "apartment"];
		var result_path = "../Result/";
		var process_path = result_path + "process/";
		var json_path = result_path + data_array[data_index] + "_" + version + ".json";
		var generation = -1;
		var doubleside = false;
		var container, stats;
		var objects = [];
		var solid_mode = "RAW";
		var camera, controls, scene, renderer;

		var raycaster;
		var mouse;
		var cross;
		var jsonfile;

		var isSetCamera = false, camera_setting;

		var min_coords = [100000,1000000,1000000];

		function next(){
			clearScene();
			if (generation < 10 ) generation++;
			load();
		}

		function pre(){
			clearScene();
			if (generation > -1)
				generation--;
			load();
		}

        function toggleData(){
            clearScene();
            generation = -1;
            data_index++;
			if (data_index == data_array.length) data_index = 0;
            load();
        }

		function clearScene(){
			objects = [];
			if (scene != undefined){
				while(scene.children.length > 0){
					scene.remove(scene.children[0]);
				}
			}

			container = document.getElementById('container');
			if (container.hasChildNodes()) container.removeChild(renderer.domElement);
		}

		function load(){
			document.getElementById("generation").innerHTML = generation;
			if (generation == -1){
				json_path = result_path + data_array[data_index] + "_" + version + "_solid.json";
			}
			else{
				json_path = "../Result/process/"+data_array[data_index]+"_g_"+generation+".json";
			}
			loadAndInit();
		}


		function showRaw(){
			clearScene();
			var inner = document.getElementById("raw");
			if (solid_mode == "RAW"){
				json_path = "../Result/"+data_array[data_index]+"_" + version+".json";
				solid_mode = "SOLID";
				inner.value == solid_mode;

			}
			else {
				json_path = "../Result/"+data_array[data_index]+"_" + version+"_solid.json";
				solid_mode = "RAW";
				inner.value == solid_mode;
			}
			loadAndInit();
		}

		function showDoubleSide(){
			clearScene();
			doubleside ^= 1;
			loadAndInit();
		}

		function loadAndInit(){
			$.getJSON(json_path, function(data) {
				console.log(data);
				jsonfile = data;
				init();
				animate();
			});
		}


		var projector = new THREE.Projector();
		load();

		function onDocumentMouseDown( event ) {

			event.preventDefault();

			mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
			raycaster.setFromCamera( mouse, camera );
			var intersects = raycaster.intersectObjects( objects );

			if ( intersects.length > 0 ) {
				intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
				console.log(intersects[0].object.name);
				console.log(jsonfile.spaces[0].Surfaces[intersects[0].object.name]);
			}

		}

		function match(){
			var coord1 = jsonfile.spaces[0].Surfaces[686].coord;
			var coord2 = jsonfile.spaces[0].Surfaces[0].coord;
			var num = 0;
			for (var i = coord1.length-1 ; i >= 0 ; i--){
				var pre_num = 0;
				for (var j = 0 ;  j < coord2.length ; j++){
					if (coord1[i][3] == coord2[j][3]) pre_num ++;
				}
				if (pre_num > 1) console.log(pre_num);
				num += pre_num;
			}
			console.log("NJNJ:", num);
		}

		function init() {
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			camera = new THREE.PerspectiveCamera(
				60,
				window.innerWidth / window.innerHeight,
				1,
				10000);
			camera.position.x = -767.2;
			camera.position.y = -891;
			camera.position.z = 708;

			//camera.lookAt(new THREE.Vector3( 0, 0, 0 ));
			//camera.updateProjectionMatrix();

			//
			// camera.position.z = 1200;
			// camera.position.y = 400;
			//camera.position.x = 50;

			controls = new THREE.TrackballControls(camera);
			controls.target.set(50,50,0);
			controls.rotateSpeed = 6.0;
			controls.zoomSpeed = 2.0;
			controls.panSpeed = 1.8;

			controls.noZoom = false;
			controls.noPan = false;

			controls.staticMoving = false;
			controls.dynamicDampingFactor = 0.3;

			controls.keys = [65, 83, 68];

			controls.addEventListener('change', render);

			scene = new THREE.Scene();
			raycaster = new THREE.Raycaster();
			mouse = new THREE.Vector2();

			scene.fog = new THREE.FogExp2(0xcccccc, 0.0002);
			if (jsonfile == undefined){
				console.log("no json");
			}
			var space = jsonfile.spaces;
			for (var i = 0; i < space.length; i++) {
				var polygon_list = space[i].Surfaces;
				console.log("polygon numbers : " + polygon_list.length);
				for (var j = 0; j < polygon_list.length; j++) {
					//if (j != 39 && j!= 181) continue;
					var coordinates = polygon_list[j].coord;
					coordinates = scaleUp(coordinates, 100);

					var normal = polygon_list[j].normal;
					var triangled_vertices = triangulate(coordinates, normal);
					if (triangled_vertices.length == 0) console.log(j);

					setMinimum(coordinates);
					var geometry = new THREE.BufferGeometry();
					var vertices = new Float32Array(triangled_vertices);

					geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
					var material;
					if (doubleside){
						material = new THREE.MeshBasicMaterial({
							color: Math.random() * 0xffffff
							//,wireframe : true
							,side: THREE.DoubleSide
						});
					}
					else{
						material = new THREE.MeshBasicMaterial({
							color: Math.random() * 0xffffff
						});
					}
					var mesh = new THREE.Mesh(geometry, material);
					mesh.name = j;
					scene.add(mesh);
					objects.push(mesh);
					//break;
				}
			}

			var axis = [1000,1000,1000];
			for (var ii = 0 ; ii < 3 ; ii++){
				var geometry = new THREE.Geometry();
				geometry.vertices.push(new THREE.Vector3(0, 0, 0));

				var vector = new THREE.Vector3(0,0,0);
				vector.setComponent(ii, axis[ii]);
				geometry.vertices.push(vector);

				var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xff0000, opacity: 0.9 } ) );
				scene.add( line );
			}

			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setClearColor(0xcccccc);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			container = document.getElementById('container');
			container.appendChild(renderer.domElement);

			window.addEventListener('resize', onWindowResize, false);

			render();

		}

		function setMinimum(coordinates){
			for (var i = 0 ; i < coordinates.length ; i++){
				for (var j = 0 ; j < 3 ; j++){
					if( min_coords[j] > coordinates[i][j]) min_coords[j] = coordinates[i][j];
				}
			}
		}

		function triangulate(coordinates, normal){
			var triangled_vertices =[];
			var vertices2d = [];

			var nx = Math.abs(normal[0]);
			var ny = Math.abs(normal[1]);
			var nz = Math.abs(normal[2]);

			var minus = false;

			if (nx >= ny && nx >= nz){
				for (var i = 0 ; i < coordinates.length ; i++){
					vertices2d.push(coordinates[i][1]);
					vertices2d.push(coordinates[i][2]);
				}
				if (normal[0] < 0) minus =true;
				//return [];
			}
			else if (ny >= nx && ny >= nz){
				for (var i = 0 ; i < coordinates.length ; i++){
					vertices2d.push(coordinates[i][2]);
					vertices2d.push(coordinates[i][0]);
				}
				if (normal[1] < 0) minus =true;

			}
			else{
				for (var i = 0 ; i < coordinates.length ; i++){
					vertices2d.push(coordinates[i][0]);
					vertices2d.push(coordinates[i][1]);
				}
				if (normal[2] < 0) minus =true;
				//return [];
			}

			var triangle_index = earcut(vertices2d);


			if (minus){
				for (var i = triangle_index.length - 1 ; i >= 0 ; i--){
					triangled_vertices.push(coordinates[triangle_index[i]][0]);
					triangled_vertices.push(coordinates[triangle_index[i]][1]);
					triangled_vertices.push(coordinates[triangle_index[i]][2]);
				}
			}
			else{
				for (var i = 0 ; i<triangle_index.length ; i++){
					triangled_vertices.push(coordinates[triangle_index[i]][0]);
					triangled_vertices.push(coordinates[triangle_index[i]][1]);
					triangled_vertices.push(coordinates[triangle_index[i]][2]);
				}
			}
			if (triangled_vertices.length == 0){
				console.log(normal);
				console.log(coordinates);
				console.log(vertices2d, "Triangulate Error");
			}

			return triangled_vertices;
		}

		function scaleUp(coordinates, scale){
			scale = scale || 100; //if undefined, 100.
			if (!Array.isArray(coordinates)){
				console.log("not array");
				return null;
			}
			for (var i = 0 ; i < coordinates.length ; i++){
				coordinates[i][0] *= scale;
				coordinates[i][1] *= scale;
				coordinates[i][2] *= scale;
			}
			return coordinates;
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			controls.handleResize();

			render();

		}

		function animate() {

			requestAnimationFrame(animate);
			controls.update();

		}

		function render() {

			renderer.render(scene, camera);

		}

		function readTextFile(file, callback) {
			var rawFile = new XMLHttpRequest();
			rawFile.overrideMimeType("application/json");
			rawFile.open("GET", file, true);
			rawFile.onreadystatechange = function() {
				if (rawFile.readyState === 4 && rawFile.status == "200") {
					callback(rawFile.responseText);
				}
			}
			rawFile.send(null);
		}

		//usage:
		// readTextFile("../Result/main_10.0_v0.2.6.1.json", function(text){
		// 	console.log(text);
		// 	var data = JSON.parse(text);
		// 	console.log(data);
		// });
	</script>
</body>

</html>
